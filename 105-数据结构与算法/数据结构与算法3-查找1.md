# 查找 1

## 直接查找

**顺序查找**

遍历元素集合，找到元素后退出。顺序查找的时间复杂度为 $O(n)$。

**二分查找**

二分查找的前提条件是元素集合有序，每次取区间的中间元素与查找元素比较，每次可以排除区间的一半。二分查找的时间复杂度为 $O(\log n)$。

## 借助数据结构进行查找

### 哈希表
哈希表非常适合元素查找，使查找的算法复杂度降到 $O(1)$。哈希表中通过哈希函数为元素与索引建立直接关系，只要确定元素的哈希值，就能确定元素所在位置。

对于哈希表，需要注意两个问题：1）选择合适的哈希函数；2）处理哈希值相同的元素。

* 哈希函数 h(key)：除法、乘法(乘以小数取整数部分)、或多种运算的组合；

* 处理重复元素的方法：
  * 每个表项为一个链表，保存相同哈希值的元素，查找时遍历这个链表。
  * 开放寻址：选用 h(key, i) 形式的哈希函数，如果同一个哈希值已经记录了 i 个元素，则用 h(key, i+1) 作为该元素的哈希值。
  * 完全散列：多级哈希，每一级的哈希函数不同，第一级的哈希值相同的元素，在第二级的哈希值基本不会相同。第一级哈希表的表项也是一个哈希表。

### 树

树也是一种对查找非常友好的数据结构，使查找的时间复杂度降低到 $O(\log h)$。树通过保持一定的有序状态来降低查找时间。

对于树，除了基本的查找、插入、删除操作，还有前序遍历、中序遍历、后续遍历、

**二叉搜索树**

二叉搜索树是满足 左子节点元素 < 父节点元素 < 右子节点元素 的二叉树，查找元素时总能确定元素是父节点或者左子树上或者右子树上，问题规模每次减半。为了保持二叉搜索树的性质，在插入或者删除元素后，二叉搜索树需要通过移动节点来恢复性质。

二叉搜索树下查找的时间复杂度与二叉树的高度有关，直接建立的二叉搜索树的高度不稳定，为了降低查找的时间复杂度，需要降低树的高度，产生了许多平衡的或近似平衡的树。

**平衡二叉树**

平衡二叉树(AVL树)是一棵左右子树高度差不超过1的二叉搜索树，此时它的高度是最小的，查找的效率也是最好的。

为了保持平衡二叉树的性质，在插入或者删除元素后，平衡二叉树也是根据不同的情况，通过旋转等操作恢复性质。

**红黑树**

红黑树是一种接近平衡的二叉搜索树，满足：
* 根节点和叶节点都是黑色；
* 红色节点的子节点都是黑色；
* 从任意节点到叶节点的每条路径黑色节点数量相同。

在插入或者删除元素后，通过旋转和颜色调整，恢复红黑树的性质。

**B树**

B树也是一种对平衡二叉树的近似，是一种多路树。

记 t 为 B 树的度，除根节点外的每个节点都有 n = [t-1, 2t-1] 个元素，有 n+1 个子节点，如 t=2 时的 B 树，每个节点可能有2、3、4个子节点，称为 2-3-4 树。B树的所有叶子节点在同一层。这种设计限制了树的最大高度，降低了查找的算法复杂度。

B树在插入元素后，如果节点数量超过限制，就把该节点分裂成一个父节点两个子节点的形式，当然为了保持叶节点的高度一致，分裂的父节点根据情况可能需要放入父节点的位置。同样的，删除操作也会导致节点合并来满足B树的性质。

B+树是B树的一种扩展，只有叶子节点保存数据，内部节点不保存数据，只保存分界信息。且每个叶子节点有指向相邻叶子节点的指针，仅访问叶子节点就能获得有序的序列。

**二叉空间分割树**

这一类树主要通过对元素空间划分，降低查找的问题规模。有 四叉树、八叉树、K-D树等。，其中四叉树与八叉树分别适合于二维和三维空间，均匀划分成四份或者八份；K-D树每次将空间一分为二，划分出的空间大小不一。


## 顺序统计量

元素集合的最值，可以通过遍历集合获得。

元素集合的第 k 大值，或者第 k 小值，或者中位数，暴力方法是将集合先排序再获得。更优的方法是采用分治思想，使用类似于快速排序的方法。选取一个元素将集合划分成左右两个子集，如果左子集的大小为 k-1，则选取元素即为所求元素，否则，根据左子集的大小可以确定所求元素在左子集还是右子集中。