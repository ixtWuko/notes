# 排序与查找

## 直接排序

**插入排序**

需要一个$O(n)$的辅助空间，对于每一个元素，按照大小顺序插入辅助空间的合适的位置，时间复杂度为 $O(n^2)$ 。

**冒泡排序**

不需要辅助空间，依次比较相邻的元素，并交换顺序不相符的，时间复杂度为 $O(n^2)$。

**归并排序**

将需要排序的集合划分成子集，对子集排序后，再进行合并，时间复杂度为 $O(n \log n)$，归并排序需要$O(n)$的辅助空间。

**快速排序**

从尾部选择一个元素作为分界，将元素集合划分成左右两个子集，递归这一过程，至子集大小为1个元素，就可以实现排序。快速排序的平均时间复杂度为 $O(n \log n)$，在使用随机初始化后更容易解决平均时间复杂度，尽管最坏时间复杂度为 $O(n^2)$，但快速排序依然是比较好的排序算法。

## 利用数据结构排序
插入排序、冒泡排序、归并排序、快速排序都是在完全无序的集合上进行的，利用某些数据结构也可以更高效地进行排序。

**堆排序**

最大堆、最小堆本质上是一棵二叉树，保存在一块连续存储中。如果连续存储的索引为 $1, \cdots, n$，则对于节点 `i`, 父节点、左子节点、右子节点的索引分别为 `parent(i) = floor(i/2)`, `left(i) = 2i`, `right(i) = 2i+1`。

最大堆总是满足父节点不小于子节点，最小堆总是满足父节点不大于子节点。

堆的功能
* 插入：在连续存储的尾端插入元素，与它的父节点比较，不满足堆的属性就交换，递归比较-交换的过程。
* 删除：删除只能删除首元素，删除后将尾元素放入首元素，与它的子节点比较，不满足堆的属性就交换，递归比较-交换的过程。

堆排序的过程，就是依次取出堆的首元素的过程。堆排序的算法复杂度是 $O(n \log n)$, 其中建队需要 $O(n)$，取一次首元素需要 $O(\log n)$。将取出的首元素放堆的尾部，这样就不需要辅助空间了。

可以看出堆排序适合于实现优先队列。

**计数排序**

计数排序适用于元素值范围不大的情况，辅助空间的索引是元素值，存储着元素出现的次数。计数排序时第一趟遍历所有元素，统计它们出现的次数，第二趟遍历辅助空间，恢复出序列。计数排序的时间复杂度为 $O(n)$，但空间复杂度较高。

**基数排序**

基数排序适用于整数的排序，每一趟都以一个数位为排序依据排序，从最低位至最高位依次进行。基数排序不需要辅助空间，时间复杂度依赖于每一趟排序时使用的排序算法。

**桶排序**

桶排序将元素值的范围划分成多个区间，每个区间一个桶。桶排序时第一趟遍历所有元素，将它们放入桶中，第二趟在桶内进行排序，最后将各个桶按顺序连接起来。桶排序需要桶的辅助孔教，时间复杂度依赖于桶内排序算法。

## 有序的数据结构

某些数据结构本身就保持着一定程度的有序状态，如前述的堆，某些高级的树等。这类数据结构能够在较低的时间复杂度下恢复出序列，是将部分排序所需的开销均摊到元素插入的环节。

## 查找

**顺序查找**

遍历元素集合，找到元素后退出。顺序查找的时间复杂度为 $O(n)$。

**二分查找**

二分查找的前提条件是元素集合有序，每次取区间的中间元素与查找元素比较，每次可以排除区间的一半。二分查找的时间复杂度为 $O(\log n)$。

## 顺序统计量

元素集合的最值，可以通过遍历集合获得。

元素集合的第 k 大值，或者第 k 小值，或者中位数，暴力方法是将集合先排序再获得。更优的方法是采用分治思想，使用类似于快速排序的方法。选取一个元素将集合划分成左右两个子集，如果左子集的大小为 k-1，则选取元素即为所求元素，否则，根据左子集的大小可以确定所求元素在左子集还是右子集中。

## 借助数据结构进行查找

**二叉搜索树**

二叉搜索树是满足 左子节点 < 父节点 < 右子节点 的二叉树，查找元素时总能确定元素为父节点或者左子树上或者右子树上，问题规模每次减半。二叉搜索树下查找的时间复杂度为 $O(\log h)$，与二叉树的深度有关。

为了保持二叉搜索树的性质，在插入或者删除元素后，二叉搜索树通过旋转操作，来恢复性质。

**平衡二叉树**

前述可以看出，降低在二叉搜索树上查找元素的时间复杂度的方法时降低树的高度，直接建立的二叉搜索树的高度不稳定。

平衡二叉树(AVL树)是一棵左右子树高度差不超过1的二叉搜索树，此时它的高度是最小的，查找的效率也是最好的。

为了保持平衡二叉树的性质，在插入或者删除元素后，平衡二叉树也是根据不同的情况，通过旋转等操作恢复性质。

**红黑树**

红黑树是一种接近平衡的二叉搜索树，满足：
* 根节点和叶节点都是黑色；
* 红色节点的子节点都是黑色；
* 从根节点到叶节点的每条路径黑色节点数量相同。

红黑树的复杂度比平衡二叉树小一些，在插入或者删除元素后，通过旋转和颜色调整，恢复红黑树的性质。

**B树**

B树也是一种对平衡二叉树的近似，B树的显著特征是每个节点有多个元素和多个子节点。记 t 为 B 树的度，处根节点外的每个节点都有 n = [t-1, 2t-1] 个元素，有 n+1 个子节点，如 t=2 时的 B 树，称为 2-3-4 树。通过这种方式，限制了树的最大高度，降低了查找的算法复杂度。

B 树在插入或者删除元素后，通过节点分裂与合并来恢复 B 树的性质。

**四叉树、八叉树、KD树**

这类树主要通过对元素值范围进行划分，每个子树代表一个区间，通过比较区间与所求元素来降低问题规模。