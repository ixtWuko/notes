# 算法概述

## 算法复杂度

时间复杂度：$O(1), O(\log n), O(n), O(n \log n), O(n^2), \cdots$

获得时间复杂度的方法：
* 直接统计算法中的运算次数和迭代次数获得时间复杂度；
* 含有递归的算法使用主方法分析获得时间复杂度；
* 含有随机的算法使用概率分析获得时间复杂度；
* 数据结构中实现功能的，每次执行的运算次数和迭代次数都不定的算法，使用摊还分析（求平均）获得时间复杂度。

空间复杂度：空间复杂度经常被忽略，在某些场景中也是非常重要的指标。没有免费的午餐，有时需要牺牲空间复杂度来改善时间复杂度。

## 迭代与递归

迭代是逼近答案的过程，递归是分解问题的过程，在程序中迭代表现为循环，递归表现为函数对自身的调用。函数调用会产生额外的开销，但并不意味着总是优先使用迭代，在递归更符合逻辑直觉，代码更简洁时应选择递归。

编译器往往会对尾递归进行优化，递归时还要考虑是否会爆栈。

## 与CPU特性相关的优化

1. CPU的执行具有局部性，尽量将连续存储的数据放在一起处理，降低内存换页的概率。
2. 流水线的CPU一般具有预测能力，分支可能会导致预测错误降低执行效率，尽量使用数据运算代替分支。

# 数据结构概述

## 连续存储、节点存储

数据结构的底层实现总会体现为连续存储、节点存储中的一种。连续存储在内存中是连续的，通过连续的内存地址访问，适合随机访问；节点存储中每个节点不仅保存一项数据，还保存指向其它节点的内存地址，用来连接节点。从内存的角度来看，连续存储需要内存中有足够大的连续空闲空间才能建立，节点存储每次只需要分配一个节点，更加灵活。

数组与多维数组是最简单的连续存储的数据结构，通过索引访问元素，索引实质是相对于起始元素地址的偏移。数组适合保存连续的数据，不适合在中间位置插入或删除元素。

链表是最简单的节点存储的数据结构，有单向链表、双向链表、循环链表等，无法直接通过索引访问元素，但适合在中间节点插入或删除元素。

树也是一种节点存储的数据结构，每个节点可以指向多个子节点，有二叉树、八叉树等，二叉树适合保存有序的数据，以较低的开销进行查找作业。

其它的数据结构也都是连续存储、节点存储或二者的组合。

## 常用基本数据结构
* 数组与多维数据：固定大小的连续存储
* 动态数组：不固定大小的连续存储
  > 数组适合于保存和查询基于索引的数据
* 链表：单向或双向的、线性的节点存储
  > 链表适合于频繁插入、删除元素的场景
* 树：树状的节点存储
  > 树适合于降低查询的复杂度
* 栈：后入先出的线性数据结构
* 队列：先入先出的线性数据结构
  > 栈与队列都可以使用连续存储实现，当然也可以使用节点存储实现
* 元组：保存key，一般为key不重复的、无序的数据结构
* 字典：保存key-value，一般为key不重复的、无序的数据结构
  > 为了高效查找，元组和字典一般使用哈希表实现
* 哈希表：一种为提高查找速度设计的数据结构，哈希表的基础是一个连续存储的表，索引为对应元素的哈希值。


### 哈希表
对于哈希表，需要注意两个问题：1）选择合适的哈希函数；2）处理哈希值相同的元素。

* 哈希函数 h(key)：除法、乘法(乘以小数取整数部分)、或多种运算的组合；

* 处理重复元素的方法：
  * 每个表项为一个链表，保存相同哈希值的元素，查找时遍历这个链表。
  * 开放寻址：选用 h(key, i) 形式的哈希函数，如果同一个哈希值已经有 i 个了，则用 h(key, i+1) 作为该元素的哈希。
  * 完全散列：多级哈希，每一级用不同的哈希函数解决冲突。第一级哈希表的表项也是一个哈希表。
