# 排序

## 直接排序

**插入排序**

需要一个$O(n)$的辅助空间，对于每一个元素，按照大小顺序插入辅助空间的合适的位置，时间复杂度为 $O(n^2)$ 。

**冒泡排序**

不需要辅助空间，依次比较相邻的元素，并交换顺序不相符的，时间复杂度为 $O(n^2)$。

**归并排序**

将需要排序的集合划分成子集，对子集排序后，再进行合并，时间复杂度为 $O(n \log n)$，归并排序需要$O(n)$的辅助空间。

**快速排序**

选择一个元素作为分界，将元素集合按大小划分成左右两个子集，递归这一过程，至子集大小为1个元素，就可以实现排序。快速排序的平均时间复杂度为 $O(n \log n)$，在使用随机初始化后更容易解决平均时间复杂度，尽管最坏时间复杂度为 $O(n^2)$，但快速排序依然是总体表现比较好的排序算法。

## 利用数据结构排序
插入排序、冒泡排序、归并排序、快速排序都是在完全无序的集合上进行的，利用某些数据结构也可以更高效地进行排序。

**堆排序**

最大堆、最小堆本质上是一棵二叉树，保存在一块连续存储中。如果连续存储的索引为 $1, \cdots, n$，则对于节点 `i`, 父节点、左子节点、右子节点的索引分别为 `parent(i) = floor(i/2)`, `left(i) = 2i`, `right(i) = 2i+1`。

最大堆总是满足父节点不小于子节点，最小堆总是满足父节点不大于子节点。

堆的功能
* 插入：在连续存储的尾端插入元素，与它的父节点比较，不满足堆的属性就交换，递归比较-交换的过程，恢复堆的性质。
* 删除：只能删除首元素，删除后将尾元素放入首元素，与它的子节点比较，不满足堆的属性就交换，递归比较-交换的过程，恢复堆的性质。

堆排序的过程，就是依次取出堆的首元素的过程。堆排序的算法复杂度是 $O(n \log n)$, 其中建队需要 $O(n)$，取一次首元素需要 $O(\log n)$。将取出的首元素放堆的尾部，这样就不需要辅助空间了。

可以看出堆排序适合于实现优先队列。

**计数排序**

计数排序适用于元素值范围不大的情况，辅助空间的索引是元素值，存储着元素出现的次数。计数排序时第一趟遍历所有元素，统计它们出现的次数，第二趟遍历辅助空间，恢复出序列。计数排序的时间复杂度为 $O(n)$，但空间复杂度较高。

**桶排序**

桶排序将元素值的范围划分成多个区间，每个区间一个桶。桶排序时第一趟遍历所有元素，将它们放入对应的桶中，第二趟在桶内进行排序，最后将各个桶按顺序连接起来。桶排序需要桶的辅助空间，时间复杂度依赖于桶内排序算法。

## 有序的数据结构

某些数据结构本身就保持着一定程度的有序状态，如前述的堆，某些高级的树等。这类数据结构能够在较低的时间复杂度下恢复出序列，是将部分排序所需的开销均摊到元素插入的环节。
