# 进程与协程

## 进程
以 linux 为例，介绍多进程的使用。

```c
#include <unistd.h>

int main() {
    pid_t pid;
    pid = fork();

    if (pid < 0) {}    // error
    if (pid == 0) {}   // 子进程
    else               // 父进程
}
```

子进程与父进程的内容大部分相同，但是并不完全相同。子进程从fork处开始继续执行，根据pid可以区分父进程和子进程。

子进程被创建后，目的是为了执行某些程序，使用 exec 函数执行外部的某些程序文件等。exec 是一族函数，参数形式不同，因为 c 没有重载。

当子进程执行结束，会关闭文件描述符、释放内存空间，但是PCB仍然存在，保存着退出状态或导致错误的原因。父进程使用 wait 和 waitpid 对子进程进行清理，此时这些子进程成为僵尸进程。

```c
pid_t wait(int* status);
pid_t waitpid(pid, int* status, int options);
// 如果清理成功，返回清理掉的子进程的id，错误返回 -1
```

**守护进程**

守护进程 daemon 是 linux 中的一种特殊的进程，它在系统启动时运行，保持运行，用来保持某种服务。

## 进程间通信

有多种进程间通信的方式，如：信号、管道、消息队列、共享内存、Socket

### 信号
信号其实是软中断，是进程间异步通信的一种方式，可以传递少量的信息。使用信号的程序可以发出软中断，接收信号的程序需要先注册处理某个信号的函数，之后等待这一信号就可以了。这里的信号与 PV 信号量是不同的概念。

### 匿名管道

当两个进程间需要通信时，可以使用 `int pipe(int filedes[2])` 创建一个管道（本质上是内存中内核区的一块缓冲区，使用环形队列实现），filedes 是文件描述符，第一个指向管道的读端，第二个指向管道的写端，使用 `read(filedes[0])` 和 `write(filedes[1])` 进行数据交换。在管道的实际使用中，父进程会先创建需要使用的管道，再 fork 出子进程，这样子进程才能获知管道的文件描述符。

可以看出管道是单向的，且只能在具有亲缘关系的进程间通信。

### 命名管道

命名管道是直接由内核提过的一种管道，在操作系统中以文件的形式存在，任何进程都可以通过文件路径访问。这种管道的文件类型是 FIFO，严格遵守先入先出的顺序，是一种全双工的管道。

### 消息队列

一种增强型的管道，消息可以包含特殊标记，消息队列可以根据特殊标记对消息进行筛选，按先进先出的方式读取消息。在高并发的环境种使用。

### 共享内存
内核种开辟的一块内存区域，通过虚拟映射的方式映射到进程的内存空间，供多个进程对同一块内存空间读写，避免数据的拷贝。

### 信号量 semaphore
信号量是一种特殊的变量，用于处理进程间的同步与互斥等，这里就是 pv 操作的内容了。

### Socket
不管是同一个系统的进程还是不同系统的进程，都可以使用 Socket进行通信。这一部分主要在网络编程的体现。


## 协程
从之前的叙述可以看出，一个线程的粒度是一个函数，在一个线程内部，函数是连续执行的，对于高并发的场景，如果在一个线程内部实现多个逻辑流的交替执行，就需要借助协程的概念。协程对应一个逻辑流或者一个函数片段。

多个协程在一个线程内部交替执行，在逻辑上多个协程是并发执行的，但是本质上多个协程的指令只有一条路径，因此协程间不存在 CPU 的调度问题，也不需要锁机制来保护变量。

在高级语言中，可以看到一些协程的例子，如果Python中的生成器，使用 yield 产生数据就是使用协程实现的。在C++中，协程已经进入新的标准，同时也有很多开源的协程库可以使用。