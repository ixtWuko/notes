# 面向对象

## move 语义

### 左值与右值
在C++中可以取得内存地址的、有名字的变量就是左值；右值则是指不能取得内存地址的、没有名字的变量。左值一定占用内存空间，右值可能占有内存空间。

有两种右值：
* 纯右值 prvalue：如 `a = 10` 中的10是一个纯右值，理论上不占用内存空间，没有对应的内存地址。
* 将亡值 xvalue：如 `a = b + c` 中的 `b + c` 会产生一个临时变量，尽管它占用内存空间，但是不会存活太久。

在C++中，使用左值的方式，可以是通过其“本名”访问，也可以通过引用访问，此时使用的引用是左值引用。但是右值没有关联名字，为了能够使用右值，C++引入了右值引用的概念。
```c++
void func(string& str);    // 这是一个左值引用
void func(string&& str);   // 这是一个右值引用
```

右值引用指向的总是将亡值，因为纯右值不占用空间，无法指向。如果指向的对象是一个纯右值，则会将其转换为将亡值。

问题是我们为什么要直接使用右值？为了避免不必要的拷贝。


### move 语义
C++中提供了 `move` 语义，用来避免上述的拷贝过程。
```c++
struct Node {
    int val;
    Node(const int& _val) : val(_val) {}
    Node(int&& _val) {
        int tmp = _val + 1;
        val = std::move(tmp);
    }
};
int input = 10;
Node node_a(input);
Node node_b(10);
```
对于想要被移动的对象，可能是一个将亡值，或者一个即将被销毁的左值。`a = std::move(b)` 中的 `move` 总是将一个将亡值或者即将被销毁的左值，转换为一个右值引用（没有其它作为），这样就可以调用 `a` 的 `operator=(T&&)` 来进行移动赋值了。

对于 `move` 而言，它不在乎被转换的对象是否真的能被移动，只是把它转换为一个右值引用。但是带有 const 属性的对象是不能被移动的。

### 完美转发
普适引用/通用引用：模板中的 `T&&`、或者`auto&&` 可能是一个右值引用，但也有可能是个左值引用。这两个地方都需要进行类型推断，可以推断为右值引用，也可以推断为左值引用。

`std::forward` 的用法：
```c++
template<typename T>
void setName(T&& newName) {
    name = func(std::forward<T>(newName));
}
```
上述函数中，不管setName的参数是左值引用还是右值引用，由于对于 func 而言，都需要一个实参，导致编译器总会把 newName 转换为左值，因为函数的参数总是左值。使用 forward 可以避免这种转换，将一个右值传入 func 中，这就是完美转发的意思——传入左值就转发左值，传入右值就转发右值。因此，对于func而言，它的左值实现与右值实现都会有用，在setName中也不会发生不必要的拷贝。

## 指针与智能指针
### 使用指针
C++ 提供了 new 和 delete 关键字来分配和释放内存（堆）
```c++
// 或者直接用 auto
string* p_str = new string{"hello, world"}; // 这种花括号的使用也是可以的
delete p_str;
```

new 与 delete 必须成对出现，使用 operator new 必须对应 operator delete，使用 placement new 必须对应 placement delete，使用 new[] 必须对应 delete[]。

placement new 与 operator new 的不同：placement new 接受的参数除了size_t 外，还有其它的，比如一个指针，指向一个已经无用的对象内存空间。

### 使用智能指针
智能指针是C++为了能够更安全地使用动态内存而产生的一种指针，与传统指针不同的地方，智能指针在不使用时会自动释放所指向的对象，避免内存空间浪费。

智能指针使用模板创建：
- auto_ptr (03标准) 遵循RAII，没有引用计数，更推荐下面的 shared_ptr。
- shared_ptr 允许多个指针指向同一个对象；
- unique_ptr 独占指向的对象；允许移动，不允许复制。
- weak_ptr 指向 share_ptr 指向的对象，但是不参与其生存期的计数，因此使用前要检查。
```c++
shared_ptr<int> p_int = make_shared<int>(10);  // 无须手动释放
// 优先使用 make_shared 而不是 new
```
智能指针本质上是一个行为类似指针的对象，采用RAII的模式，在它的构造函数中，申请内存并构造对象，在它的析构函数中，析构对象并释放内存。

其它类似的资源，也可以采用类似的资源管理方式——在构造函数中分配，在析构函数中释放。
对于不同的资源，需要决定资源管理类的 copy 行为，比如：禁止 copy、使用引用计数的 copy 等等。

为什么会有 weak_ptr？为了解决循环引用问题。因为 shared_ptr 可以复制，可能会发生实例A中的 shared_ptr 成员指向实例B，实例B中的 shared_ptr 成员指向实例A，这样二者都无法进行释放，使用 weak_ptr 用来解决这种循环引用的问题。

## 类的定义
关键字 struct 与 class 用于类的创建，区别为 struct 中的所有成员默认都是公开的，而 class 中的所有成员默认都是私有的。

### 构造函数
**默认构造函数**

默认构造函数没有参数，在类设计者没有主动声明任何一个构造函数时，编译器根据自己的需要进行生成，
* 成员中有其它类，而这个类带有默认构造函数，编译器会合成默认构造函数调用这个成员的默认构造函数；
* 基类带有默认构造函数，编译器会合成默认构造函数调用基类的默认构造函数；
* 有虚函数成员，编译器需要生成虚指针，因此会合成默认构造函数初始化虚指针；
* 虚继承自某个类，编译器需要生成指向虚基类的内存位置，因此会合成默认构造函数初始化该指针。

从上面的内容可以看出，编译器并不总是合成默认构造函数，且在合成的默认构造函数中，也不会对所有的成员进行初始化，因此手工初始化是必要的。

如果需要默认构造函数，可以手工指定 `classname() = default`。

**普通的构造函数**

使用带有参数的构造函数，为类的成员变量赋初始值，以及进行一些其它的初始化动作。这里可以使用**初始值列表**：
```c++
classname(const type& _a, const type& _b) : var_a(_a), var_b(_b), var_c(0) {}
```
初始值列表即函数参数之后、函数体之前的部分，还可以在这一部分使用默认初始值来初始化成员变量。

对于类内的 const 成员变量，只能使用初始值列表进行初始化。
使用列表初始化构建类的实例时，会使用该初始值列表，按照**成员变量的声明顺序**进行初始化。

**委托构造函数**

在构造函数中使用同一类的其它构造函数，就是委托构造函数。委托构造函数的形式：
```c++
classname(const type& _a) : classname(_a, 0) {}
```
这个构造函数使用了上述的带有初始值列表的构造函数。

**转换构造函数**

由于 C++ 提供的隐式转换，使得构造函数能够使用的参数类型范围更大。如果不想要这种隐式类型转换，可以使用 `explicit` 修饰构造函数，只能使用在声明处。


**拷贝构造函数**

拷贝构造函数的参数是类本身，用来实现类的拷贝行为。此外，还有拷贝赋值也实现了类的拷贝，是通过重载 `=` 运算符实现的。
```c++
classname(const classname& _c) : var_a(_c.a), var_b(_c.b), var_c(_c.c) {}
classname& operator=(const classname& _c) {
    if (this != &_c) { copy;}  // 处理自我赋值
    return *this;              // 返回一个引用，对于 += 这类运算符的重载也是要返回一个引用
 }

classname p1(p2);        // 拷贝
classname p1 = p2;       // 赋值
```
如果没有手工创建拷贝构造函数和拷贝赋值函数，编译器会自动合成；如果想显式地要求编译器合成拷贝构造函数和拷贝赋值函数，使用 `=default`；如果想禁止类有拷贝的能力，阻止任何的拷贝构造函数和拷贝赋值函数，使用 `=delete`。

**移动构造函数**
移动构造函数与拷贝构造函数很类似，用来实现类的移动行为。同样的，也有移动赋值运算符。
```c++
classname(classname&& _c) : /* 这里不写了 */ {}
classname& operator=(classname&& _c) { return *this; }
```
编译器不会为类合成移动构造函数和移动赋值函数。

### 析构函数
析构函数用于销毁实例。如使用 `delete p` 是会调用 `p` 的析构函数进行销毁。

对于一些特殊的用法，比如制作单例、禁止复制等设计模式，是通过将构造函数或析构函数私有来实现的，在现代C++中，更推荐使用 `= delete` 来实现。

### 友元
友元是用来控制其它的函数或对象，访问本对象的非公开成员的方法。比如使用打印函数将本对象打印到屏幕，本对象中的某些成员变量是私有的，通过对打印函数添加 friend 前缀，使它可以访问这些私有成员变量。

## 面向对象编程
面向对象编程的三个特征是：封装、继承、多态。

### 封装
对于 C++ 而言，封装的概念很好理解：通过类的抽象，许多细节被隐藏在了类的内部，使类的用户只需要关心接口如何使用即可；以及使用 `public`, `private`, `protected` 对类成员的权限控制，使类的使用者不会触及他们不该访问的类成员。

### 继承
C++ 支持单一继承或多重继承，提供抽象类的概念，以及使用 `public`, `private`, `protected` 进行继承中权限的控制，都是对继承的支持。
* public 继承：基类中的公有成员是派生类的公有成员，基类中的私有成员派生类不能访问。
* protected 继承：基类中的公有成员和保护成员在派生类中都是保护成员。
* private 继承：基类中的公有成员和保护成员在派生类中都是私有成员。

C++中的public继承应当看作一种 is-a 的关系，即派生类的实例也是基类的实例。
C++中的类的复合应当看作一种 has-a 的关系，即复合体拥有一个类的实例。
根据不同的使用场景来决定使用 public 继承方式还是使用类的复合的方式，不要一味地使用继承。

### 多态

#### 虚函数
虚函数为允许基类调用的派生类的函数。在派生类中不一定要重新定义基类的虚函数，但是重新定义后，基类和派生类就会对该函数拥有各自的版本，在调用该函数时动态绑定。借助指针或引用，能够实现多态的效果。
```c++
class base {
    virtual type func() {}
}
class deriver : public base {
    virtual type func() {}
}

// 此时使用 base 类型的指针定义 deriver 的对象
base* obj = new deriver();
obj.func();    // 此时会使用 deriver 中的 func，而不是 base 中的 func
```
从上面的例子可以看出，带有虚函数的类，**析构函数最好定义成虚函数**，否则 obj 可能不能正确地析构。

虚函数的动态绑定是由虚表和虚指针实现的，对于基类和派生类，都由于一个虚表，记录其拥有的虚函数，对于每个实例，在构造时获得一个成员变量--虚指针，指向对应的虚表。当调用虚函数的，通过虚指针查询虚表，实现动态绑定。

不要在构造函数和析构函数中调用其它虚函数，因为不能保证虚指针在调用虚函数时是存在的。

纯虚函数为没有实现的函数。纯虚函数的目的是要求派生类必须实现这一函数，主要是为了规范派生类的功能。带有纯虚函数的类称为抽象类，因为纯虚函数没有实现，无法进行实例化。
```c++
virtual type function(args) = 0;    // 纯虚函数
```

#### 多态的实现
在继承中比较容易混淆的是普通成员函数、虚函数、纯虚函数，这里以类指针下的三个函数调用说明区别：
```c++
class base {
public:
    string f() { return "base.f"; }            // 普通函数
    virtual string g() { return "base.g"; }    // 虚函数
    virtual string h() = 0;                    // 纯虚函数
};
class deriver : public base {
public:
    string f() { return "deriver.f"; }
    virtual string g() { return "derivr.g"; }
    string h() { return "deriver.h"; }
};
int main() {
    base*     pb = new deriver();
    deriver*  pd = new deriver();
    // 普通的成员函数
    cout << pb->f() << endl;  // -> base.f
    cout << pd->f() << endl;  // -> deriver.f
    // 虚函数
    cout << pb->g() << endl;  // -> deriver.g
    cout << pd->g() << endl;  // -> deriver.g
    // 纯虚函数
    cout << pb->h() << endl;  // -> deriver.h
    cout << pd->h() << endl;  // -> deriver.h
}
```
从上面的比较可以看出：
- 对于普通的成员函数，对它的调用取决与实例声明的类型，声明为一个 base 类型时，就会使用 base 的普通成员函数，声明为一个 deriver 类型时，就会使用 deriver 的普通成员函数。
- 对于虚函数，对它的调用取决与实例的实质类型，这里实质上两个指针指向的都是 deriver 类型的，所有都会使用 deriver 类型的。
- 对于纯虚函数，抽象类不会实现，只会使用派生类的。

上面的比较可以看出，使用普通成员函数时，基类更像是多种类型相同点的抽象，使用中直接使用派生类会比较合适（实现继承）。而使用虚函数和纯虚函数时，基类看上去更像是多种派生类的统一接口，通过使用基类调用接口相同但行为不同的派生类的功能（接口继承）。这样对于同一基类下的派生类，使用基类作为某个函数的参数就能定义出所有派生类的行为，否则就需要每一个派生类单独定义。这种方式是多态的体现。使用实现继承方式时，不应该使用虚函数；使用接口继承时，基类应该声明虚函数和虚析构函数。

基于对接口与实现的分离，对象的使用尽量采用指针或引用的方式。
需要额外注意的是，使用基类的指针或引用来声明派生类时，是无法调用基类中未声明的成员的，因为编译器会把指针指向内存的模型解释为基类的内存模型，这样基类的指针或引用无法获知只在派生类中声明的成员。