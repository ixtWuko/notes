
0807
C++ 是语言的联邦，这种划分有利于记忆。


enum hack
使用 enum 定义常量的技术，因为 enum 类型本身默认就是一个整形。
```c++
// 为了定义一个整形变量
enum { Num = 5 };
```


某些成员函数可以返回对象成员变量的引用或指针，然后外部的使用者可以通过这些引用或指针修改对象的成员变量，比如对 `[]` 运算符的重载。

对于一个非const实例，上述这种外部的修改是允许的；对于一个const实例，这种修改往往是不允许的。因此需要重载成员函数，适应非const和const时的情况。
```c++
const type& operator[](int idx) const {}
type& operator[](int idx) {}
```
如果这个成员函数非常复杂，那两个成员函数中重复的代码会非常多，可以采取下面这种方式：
```c++
const type& operator[](int idx) const {} // const版本的正常定义
type& operator[](int idx) {
    return const_cast<type&>(    // 去除 cosnt
        static_cast<const className&>(*this)[idx];  // 为非常量的实例本身提供一个 const 的引用
    )
}
```


C++ 两个源码文件间的、不是函数内的 static 对象的初始化次序是不明确的，解决办法是将这种 static 对象放置在一个函数中。
```c++
type& func() {
    static type var;
    return var;
}
```
这样既可以通过函数来读取静态变量，也可以通过函数设置变量。
尽量使用传常量引用，除了内置类型、迭代器和函数对象。


如果没有声明任何构造函数，编译器会自动合成一个默认构造函数；
如果没有声明拷贝构造函数、拷贝赋值函数、析构函数，编译器也会自动合成这些。
如果没有声明移动构造函数、移动赋值函数，编译器并不会做什么。

如果不想要拷贝构造函数、拷贝赋值函数，不写的话是不行的，《effective c++》中是将它声明为 private 的并且不实现，现在的话直接使用 `=deleta` 就可以了。

`operator=` 应返回 `*this`。
`operator=` 在使用时，可能会有 `a = a` 的行为，如果在 `operater=(rhs)` 中删除了 `rhs`， 就会发生错误。应该在删除前做一个判断，是否是其本身。这是书里的论述，删除可能是针对临时变量的，因为这本书里没有移动语义的部分，现在一般都会使用移动。

多态基类使用 virtual 析构函数。当然一个基类中含有 virtual 函数，基本可以推断它会作为多态基类使用。因此对于不想作为多态基类使用的，不应该有任何 virtual 函数。

析构函数不应该抛出异常，使用 `noexcept`。不应该在构造函数和析构函数中调用 virtual 函数，因为指向实例的指针可能是出基类的，也可能是派生类的，使用 virtual 函数的构造函数和析构函数，行为是不可预测的。


将资源放在对象里，可以借助析构函数实现资源的自动释放，比如放在 shared_ptr 中。
放在对象中的另一个问题是：是否允许这个对象被复制？有些资源是单一的、独占的，允许复制并不是好的行为，可以在对象中声明禁止；有些资源可以复制，这时候就要结合 shared_ptr 的计数能力来管理。

使用 `new` 分配数组时，要使用 `delete []` 释放。如果这两个无法在一起，可以使用 shared_ptr，在 shared_ptr 的删除器中使用 delete，不过还是尽量让这两个在一个位置比较好。


（封装：）成员变量要设为private的，使用接口函数读。非成员函数比成员函数更具封装性，因为成员函数可以访问对象的所有成员，而非成员函数只能访问 public 的成员。不能一味地将所有的函数都置为成员函数，也要合理使用非成员函数。


swap 只需要对象有拷贝构造函数就可以了。条款25条的内容很好，关于模板偏特化的限制。


《effective c++》中说不应该重新定义非虚函数，不应该重新定义缺省值，因为只有虚函数是动态绑定的，其它的都是静态绑定的，重新定义会导致一些问题。public 继承是 is-a 的关系，即派生类对象就是一个基类对象，通过基类类型的变量访问派生类时，行为也应该是派生类的，非虚函数无法实现这种动态绑定。复合是 has-a 的关系，即派生类对象包含一个基类对象。
private 继承，基类的所有成员在派生类中都会变成 private 的。